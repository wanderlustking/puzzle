import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

public class Ololo {

    public static  void main(String[] args){
         String text= "(Рьдьвьл ыжх) Й вэышдеп йшщкгшп щшаидйэ э йьющьфьыковс пьшнь кщжно. Цедь ьхьдь тшвещшз тойьф куэ, хьнко пе южйвидийс ф южвс - Дшнщоу, Бюившщ, йьцохо и э. Бюившщ ушй хьйж и дьюове; ьу уойвьэд уо чвьп уш ьв ирцевхо дбцшруьйви иди ыш ющидшыоуиэ, уь, хох э юьдоноб, ир йвщозо кьфшщивс чви ьщжкиэ йфьшпж ньйюькиуж. Фик ж ушнь цед ющшжющэпел. \"Тшщвьф ыжх!\" - фьв шкиуйвфшууьш, твь э жйдеаод ьв ушнь ро фйш южвшашйвфиш. Пуш юьщжтиди кфо юьволуез мьуощэ. Дшнщоу ушй ыжхо. Ыжх цед ющифэроу х хьугж аужщо, ю Дшнщоу хщжвид шнь уо зькж, хох рохдиуовшдс. Хьнко э ропшвид чвь уьфьш эфуьш кьхоровшдсйвфь цшржпиэ пьшнь кщжно, э й вщжкьп жкшщыодйэ ьв йдшр. Вшп уш пшушш э юьхо щшаид уи ф тшп уш юшщштивс Дшнщоуж и ыковс йджтоэ, хьнко э йпьнж ющшкющиуэвс хохиш-диць чушщнитуеш пшще. Э юьюеводйэ ушйхьдсхь щор рофэровс цшйшкж ь гшдэз юьзько, уь цшржйюшауь. Жньфьщиф пшуэ икви фпшйвш й уип и кьфьдсуел чвип, Дшнщоу, фикипь, уш зьвшд цьдсаш фшйви уихохиз щорньфьщьф, и уо фйш пьи щоййющьйе ьвфштод ькуьйдьыуь: \"Жфикип!\" Кьлкэ кь пейо, пе йшди ф эдих и юшщшющофидийс уо повшщих. Юьвьп фрьцщодийс юь фейьхьпж цшщшнж и, фрэф уоющофдшуиш уо йшфшщь-роюок, жнджцидийс ф кихил, южйвеууел хщол, нкш, хородьйс, уихьнко уш йвжюодо уьно тшдьфшхо. Дшнщоу жфшщшууь фшд уой фюшщшк, диас ирщшкхо ьйвоуофдифоэйс и йфшщээйс й ьщишувищопи, хьвьщеш, фикипь, роющипшвид, юьйшяоэ чви пшйво кь вьнь. Вох пе ади тойо кфо, и уо роховш юшщшк уопи ьвхщедойс жнщбпоэ пшйвуьйвс, шяш цьдшш пщотуоэ, тшп фйш, твь пе фикшди кь йиз юьщ. Чвь цед щьк юдовь, щойхиужфашньйэ ж юькуьысэ юьтви ушющийвжюуьнь йхдьуо и юьщьйашнь дшйьп ьв уирж кь йопьнь фшщзо. Йхдьу цед жйшэу нщьпокуепи фоджуопи, хьвьщеш, хородьйс, иш юокоди фуир ф кьдиуж диас юьвьпж, твь кшщшфсэ ющшнщоыкоди ип южвс. Нджцьхиш щоййшдиуе юшщшйшходи юдовь фь фйшз уоющофдшуиэз и ющикофоди юшлроыж шяш цьдсажб кихьйвс. Юдьйхьньщсш, юь хьвьщьпж пе юькуиподийс, йюдьас юьщьйдь шышфихьл. Фйхьщш йводь эйуь, твь цшр хьйе уоп йхфьрс рощьйди уш ющьцщовсйэ. Юь ющихорж Дшнщоуо Бюившщ йвод фехоаифовс кдэ уой вщьюиухж х вбдсюоуьфьпж кшщшфж ушьцехуьфшууьл фейьве, хьвьщьш йвьэдь, ьхщжышууьш кшйэвхьп кжцьф, и кодшхь ющшфьйзькидь и чви кжце, и фььцяш фйш кшщшфсэ, хохиш пуш ющизькидьйс хьнко-диць фикшвс, щойхикийвьл хщьуьл, фшдитофьл хщойьвьл дийвфе и гощйвфшууьйвсб ьцяиз ьтшщвоуил. Хьнко пе ющиади уохьушг х гшди, Дшнщоу ьцшщуждйэ х Бюившщж и йющьйид, йпьышв ди ьу фрьцщовсйэ уо чвь кшщшфь. Йвощих цед йюшщфо ьрокотшу фьющьйьп и уитшнь уш ьвфшвид. Юьвьп, юькьлкэ х дшйуьпж ниноувж, ьу ьцьашд йвфьд хщжньп, фуиповшдсуь фндэкефоэйс. <...> Фь фщшпэ чвьнь киодьно Бюившщ цед йхщев дийвфьл кшщшфо. Уь ыжх, хьвьщьнь ьу йюжйвид фуир, фикушдйэ вшюшщс уо хьугш аужщхо. Розькэяшш йьдугш шяш ьйфшяодь фьрфеашууьйвс, нкш пе йвьэди, и ф юьйдшкуиз шнь джтоз ыжх йфшщхужд, хох юьдищьфоууел рьдьвьл аощих. Ьу йфьцькуь йфийод пшыкж фшвфшл кшщшфо, и шйди ц Бюившщ йшлтой ьвюжйвид аужщьх, вьв жюод це ющэпь х уоаип уьноп. Дшнщоу цейвщь йзфовид хьйж и щойтийвид жтойвьх киопшвщьп ф кшфэвс - кфшуокговс мжвьф, юьйдш тшнь ьу фшдшд Бюившщж ьвюжйвивс аужщьх и йдшровс юьйхьщшш фуир. Роциф хьдеашх вьтуь ф вьп пшйвш, хжко жюод ыжх, пьл кщжн февояид ир хощпоуо ршпдшпшщужб дшувж. Ющихщшюиф шш ро хьушг х йвфьдж кшщшфо, хох щор уоющьвиф роцивьнь хьдеахо, ьу ющьвэужд шш ющэпь, кь хьдеахо, юьйдш тшнь, ющькьдыоэ щорповефовс дшувж и ьвйвжюоэ уорок, ьвпшщид шяш юэвскшйэв мжвьф. Бюившщ й хьйьл ф щжхоз ашд юшщшк уип, йщшроэ хжйве шышфихи. Кьлкэ кь ужыуьнь пшйво, Дшнщоу роцид шяш ькиу хьдеашх и, ющиуипоэ шнь ро гшувщ, ьтийвид хщжн киопшвщьп ющипшщуь ф тшвещш мжво. Юьвьп ьу код юь дьюовш пуш и Бюившщж, йоп фрэд дьюовж и ющихород уоп хьюовс.";
      String key1 ="рьдьвьл ыжх";
      String key2 ="й вэышдеп йшщкгшп щшаидйэ э йьющьфьыковс пьшнь кщжно";

//          System.out.println("click "+ text.split("[\\s]").length);
        String formattedText= text.toLowerCase().replace(" ","").replaceAll(",","").replace("(","").replace(")","").replace(".","").replace("-","");
        char [] ololo = formattedText.toCharArray();
        HashMap<String, Double> actualFreq = new HashMap<String, Double>();

        HashMap<String, Double> theorFreq = new HashMap<String, Double>();

        fillTheor(theorFreq);
        fillActual(formattedText, ololo, actualFreq);
        HashMap<String,ArrayList<String>> result = new HashMap<String, ArrayList<String>>();
        for(Map.Entry<String,Double> actualEntry:actualFreq.entrySet()){
            String letter = (String) actualEntry.getKey();
            ArrayList<String> possibleValues = new ArrayList<String>();
            for(Map.Entry<String,Double> theorEntry:theorFreq.entrySet()){
                if(Math.abs(theorEntry.getValue()-actualEntry.getValue())<0.4){
                    possibleValues.add(theorEntry.getKey());
                }
            }
            result.put(letter,possibleValues);

        }
        ArrayList<String> words = new ArrayList<String>();
        char [] codedLetters = key2.toCharArray();
        words.addAll(result.get(codedLetters[0]+""));

        System.out.println(0 +" = " + result.get(codedLetters[0]+""));
        for(int i =1;i<codedLetters.length;i++){
            String codedLetter = codedLetters[i]+"";
            ArrayList<String> valuesForCurrentLetter = result.get(codedLetter);
            System.out.println(i +" = " + result.get(codedLetter));
            ArrayList tempWords = new ArrayList();
            for(String value: valuesForCurrentLetter){
                for(String word:words){
                    tempWords.add(word+value);
                }
            }
            words.addAll(tempWords);
        }

        for(String word:words){
            if(word.length()==codedLetters.length){
                System.out.println(word);
            }
        }
    }

    private static void fillTheor(HashMap<String, Double> theorFreq) {
        List<String> lines = null;
        try {
            lines = Files.readAllLines(Paths.get("C:\\Projects\\puzzle\\ololo\\src\\text"), StandardCharsets.UTF_8);
        } catch (IOException e) {
            e.printStackTrace();
        }
        for(String line: lines){
            String[] st = line.trim().split(" ");
            theorFreq.put(st[0],Double.parseDouble(st[1])*100);
        }
        System.out.println("Theor "+ theorFreq);
    }

    private static void fillActual(String formattedText, char[] ololo, HashMap<String, Double> actualFreq) {
        ArrayList formattedResult = null;
        for (int i = 0; i < ololo.length; i++) {
            String currentSymbol = String.valueOf(ololo[i]);
            if (!actualFreq.containsKey(currentSymbol)) {
                double symCount = 0;
                for (int j = 0; j < ololo.length; j++) {
                    if (currentSymbol.equals(String.valueOf(ololo[j]))) {
                        symCount++;
                    }
                }

                actualFreq.put(currentSymbol, Double.valueOf((symCount / formattedText.length())) * 100);
            }
            formattedResult = new ArrayList(actualFreq.entrySet());
            Collections.sort(formattedResult, new Comparator<Map.Entry<String, Double>>() {
                public int compare(Map.Entry<String, Double> o1, Map.Entry<String, Double> o2) {
                    if ((o2.getValue() - o1.getValue()) > 0) {
                        return 1;
                    } else {
                        return -1;
                    }
                }
            });
        }

        System.out.println("Actual " + formattedResult);
    }
}
